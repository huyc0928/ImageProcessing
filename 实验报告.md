# 2025秋CS1003.21计算机程序设计大作业实验报告

## C语言数字图像处理

**PB25111633 胡运晨**

### 0. 准备工作

#### 0.1 主结构

1. 读入图像（已提供），保存至```unsigned char* image```
2. 声明输出图像用的指针```unsigned char* output```并**申请内存**
3. 输出提示词，并读入操作类型
4. ```switch```至不同task的主函数
5. 写出函数图像（已提供）
6. **释放内存**

代码如下：

```c
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#define PI 3.14159265358979323846
#define STB_IMAGE_IMPLEMENTATION
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "D:\USTC\Program\ImageProcessing\stb_image.h"
#include "D:\USTC\Program\ImageProcessing\stb_image_write.h"
#include "task.h"
int main()
{
	int width, height, channels;
	unsigned char* image = stbi_load("D:\\USTC\\Program\\ImageProcessing\\ImageProcessing\\TestData\\alphabet1.jpg", &width, &height, &channels, 1);//读入图像用的函数
	unsigned char* output = (unsigned char*)malloc(width * height * channels);
	int ctrl;
	printf("要进行何种操作？\n1-图像的平移旋转和放缩\n2-图像的直方图均衡化\n3-图像的空间域滤波去噪\n4-彩色图像的K-means算法有损压缩\n5-图像的频率域滤波\n6-图像的四叉树分裂合并算法\n");
	scanf("%d", &ctrl);
	switch (ctrl) {
	case 1:
		task1(image, output, width, height, channels);
		break;
	}
	stbi_write_jpg("D:\\USTC\\Program\\ImageProcessing\\ImageProcessing\\TestData\\task1.jpg", width, height, 1, output, 100);//写出函数的图像
	stbi_image_free(image);
	free(output);//释放内存的函数
	return 0;
}
```

#### 0.2 基本函数

1. 坐标转换函数：将输入的行数、列数转换为一维数组中的坐标（坐标=行数*宽度+列数），返回坐标

	```c
	int trans(int row, int column, int width) {
		return row * width + column;
	}
	```

2. 

### 1. Task1 图像的平移旋转和放缩

#### 1.1 数据准备

1. 输入的角度为角度制，需要转换为弧度制，实现代码为`angle = angle * PI / 180.0`，其中`PI`为圆周率，已在头文件中定义
2. 行数和列数的计算：使用`i`控制计算循环，则行数`row = i / width`，列数`column = i % width`

#### 1.2 旋转算法

```c
originrow = cos(angle) * (row - centrerow) + sin(angle) * (column - centrecolumn) + centrerow;
origincolumn = -sin(angle) * (row - centrerow) + cos(angle) * (column - centrecolumn) + centrecolumn;
```

1. 平移：将现有的行列坐标转换为以输入的中心为原点的坐标（减掉中心点的坐标）
2. 旋转：参考已提供的矩阵旋转公式进行反向旋转，得到在原图像中对应的坐标

#### 1.3 最近邻插值法

```c
nearestNeighbor(image, output, i, round(originrow) * width + round(origincolumn), width, height);
void nearestNeighbor(unsigned char* image, unsigned char* output, int i, int origini, int width, int height) {
	if (origini >= width * height || origini < 0) {
		output[i] = 0;//边界处理
	}
	else {
		output[i] = image[origini];
	}
}//最近邻插值法
```

1. 最近邻：借助`<math.h>`中的`round`函数实现四舍五入，找到最近的点
2. 边界处理：在原图像坐标之外的点（`origini >= width * height || origini < 0`）直接赋0

#### 1.4 双线性插值法

```c
void bilinearNeighbor(unsigned char* image, unsigned char* output, int row, int column, double originrow, double origincolumn, int width, int height) {
	if (trans(originrow, origincolumn, width) >= width * height || trans(originrow, origincolumn, width) < 0) {
		output[trans(row, column, width)] = 0;//边界处理
	}
	else {
		int f_a = image[trans((int)originrow, (int)origincolumn, width)];
		int f_b = image[trans((int)originrow, (int)origincolumn + 1, width)];
		int f_c = image[trans((int)originrow + 1, (int)origincolumn, width)];
		int f_d = image[trans((int)originrow + 1, (int)origincolumn + 1, width)];
		double f_e = (originrow - (int)originrow) * (f_c - f_a) + f_c;
		double f_f = (originrow - (int)originrow) * (f_d - f_b) + f_b;
		double f_xy = (origincolumn - (int)origincolumn) * (f_f - f_e) + f_e;
		if (f_xy > 255) {
			f_xy = 255;
		}
		else if(f_xy < 0) {
			f_xy = 0;
		}
		output[trans(row, column, width)] = f_xy;
	}
}//双线性插值法
```

1. 该算法直接翻译自大作业文档，不再赘述
2. 边界处理：同1.3.2
3. 插值数据`f_xy`溢出：小于0的数据直接赋0，大于255的数据直接赋255
